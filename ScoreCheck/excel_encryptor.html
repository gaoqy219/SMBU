<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Excel成绩单加密转JSON</title>
    <style>
        .container { width: 600px; margin: 50px auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; }
        .form-group { margin: 20px 0; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input, button { padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; }
        #excelFile { width: 100%; }
        #encryptBtn { background: #4285f4; color: white; border: none; cursor: pointer; }
        #encryptBtn:disabled { background: #ccc; cursor: not-allowed; }
        #result { margin-top: 20px; padding: 10px; border-radius: 4px; }
        .success { background: #e8f5e9; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <div class="container">
        <h2>Excel成绩单加密转JSON</h2>
        
        <!-- 1. 上传Excel文件 -->
        <div class="form-group">
            <label for="excelFile">选择Excel文件（.xlsx/.xls）：</label>
            <input type="file" id="excelFile" accept=".xlsx,.xls" required>
        </div>

        <!-- 2. 设置加密密码 -->
        <div class="form-group">
            <label for="encryptPwd">设置加密密码（后续解密需相同密码）：</label>
            <input type="password" id="encryptPwd" placeholder="请输入8-16位密码" required>
        </div>

        <!-- 3. 执行加密并导出JSON -->
        <div class="form-group">
            <button id="encryptBtn">加密并导出JSON</button>
        </div>

        <!-- 结果提示 -->
        <div id="result"></div>
    </div>

    <!-- 引入依赖库（Excel解析+加密） -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script> <!-- Excel解析 -->
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script> <!-- 加密 -->

    <script>
        // 页面元素获取
        const excelFile = document.getElementById('excelFile');
        const encryptPwd = document.getElementById('encryptPwd');
        const encryptBtn = document.getElementById('encryptBtn');
        const result = document.getElementById('result');

        // 按钮点击事件：执行加密流程
        encryptBtn.addEventListener('click', async () => {
            try {
                // 1. 验证输入
                if (!excelFile.files[0]) {
                    showResult('请先选择Excel文件', 'error');
                    return;
                }
                if (encryptPwd.value.length < 8 || encryptPwd.value.length > 16) {
                    showResult('密码需为8-16位', 'error');
                    return;
                }

                // 2. 解析Excel文件
                const excelData = await parseExcel(excelFile.files[0]);
                if (excelData.length === 0) {
                    showResult('Excel文件中无数据', 'error');
                    return;
                }
                showResult('Excel解析成功，正在加密...', 'success');

                // 3. 加密数据（AES算法，与解密网页保持一致）
                const encryptedData = encryptData(excelData, encryptPwd.value);

                // 4. 导出为JSON文件
                exportJsonFile(encryptedData, excelFile.files[0].name.replace(/\.(xlsx|xls)$/, '') + '_encrypted.json');
                showResult('加密完成！JSON文件已下载', 'success');

            } catch (err) {
                showResult('操作失败：' + err.message, 'error');
            }
        });

        /**
         * 解析Excel文件：提取表格数据（返回数组）
         * @param {File} file - Excel文件对象
         */
        function parseExcel(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        // 读取Excel二进制数据
                        const data = new Uint8Array(e.target.result);
                        // 解析为工作簿
                        const workbook = XLSX.read(data, { type: 'array' });
                        // 取第一个工作表的数据（默认读取第一个sheet）
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        // 转换为JSON数组（header: 1 表示用行索引，header: 'A' 表示用列名）
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        resolve(jsonData);
                    } catch (err) {
                        reject(new Error('Excel解析失败：' + err.message));
                    }
                };
                reader.onerror = () => reject(new Error('文件读取失败'));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * 加密数据：AES对称加密（与解密网页算法一致）
         * @param {Array} data - 待加密的Excel数据（数组）
         * @param {string} pwd - 加密密码
         */
        function encryptData(data, pwd) {
            // 1. 将数组转为JSON字符串
            const jsonStr = JSON.stringify(data);
            // 2. AES加密（模式：CBC，填充：Pkcs7，密钥：密码MD5处理，偏移量：固定16位）
            const key = CryptoJS.MD5(pwd).toString(); // 密钥（32位，MD5加密密码）
            const iv = CryptoJS.enc.Utf8.parse('1234567890abcdef'); // 偏移量（固定16位，解密需相同）
            const encrypted = CryptoJS.AES.encrypt(
                jsonStr,
                CryptoJS.enc.Hex.parse(key),
                { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }
            );
            // 3. 返回加密后的Base64字符串
            return encrypted.toString();
        }

        /**
         * 导出JSON文件：浏览器下载
         * @param {string} encryptedData - 加密后的数据
         * @param {string} fileName - 文件名
         */
        function exportJsonFile(encryptedData, fileName) {
            // 1. 构建JSON结构（包含加密数据和格式标识，便于解密识别）
            const jsonContent = JSON.stringify({
                type: 'excel_encrypted', // 类型标识
                data: encryptedData,     // 加密后的数据
                timestamp: new Date().getTime() // 加密时间
            }, null, 2); // 格式化JSON（便于查看）

            // 2. 创建Blob对象并下载
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url); // 释放URL
        }

        /**
         * 显示结果提示
         * @param {string} msg - 提示内容
         * @param {string} type - 类型（success/error）
         */
        function showResult(msg, type) {
            result.textContent = msg;
            result.className = type;
        }
    </script>
</body>
</html>